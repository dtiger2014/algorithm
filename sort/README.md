# 排序算法
- https://www.cnblogs.com/onepixel/articles/7674659.html

### 冒泡排序 Bubble Sort

### 选择排序 Selection Sort(time:O(n^2))

### 插入排序 Insertion Sort(time:O(n^2))
- 思路：类似于玩斗地主，
- 比选择排序性能更优的原因：可以更快停止内层循环
- 近乎有序的数组，插入排序性能非常好。变成time:O(n)
    - 使用场景：日志数据，有可能一些数据顺序不一致

### 希尔排序 Shell Sort
- 将无序数组分割为若干个子序列，子序列不是逐段分割的，而是相隔特定的增量的子序列，对各个子序列进行插入排序；然后再选择一个更小的增量，再将数组分割为多个子序列进行排序......最后选择增量为1，即使用直接插入排序，使最终数组成为有序
- 算法复杂度
    - 平均时间复杂度：希尔排序的时间复杂度和其增量序列有关系，这涉及到数学上尚未解决的难题；不过在某些序列中复杂度可以为O(n1.3);
    - 时间复杂度：O（nlogn）～O（n2），平均时间复杂度大致是O(n√n)
    - 空间复杂度：O(1)
    - 稳定性：不稳定
### 归并排序 Merge Sort
- 归并排序：分治算法

### 快速排序 Quick Sort
- 快速排序：分治算法
- 双路快速排序
- 三路快速排序

### 归并排序和快速排序的衍生问题
- 逆序对：衡量数组的有序程度
    - 什么是 逆序对： 数组中随意抽出 2个元素，第一个元素比第二个元素大，则为逆序对
    - 可以使用归并排序的方式 求出逆序对
- 取数组中第n大的元素
    - quick sort思路，O（n）复杂度，求出

### 堆排序
- 主要用在动态数据的维护
- Heapify 的算法复杂度
    - 将n个元素逐个插入到一个空堆中，算法复杂度是O（nlogn）
    - heapify的过程，算法复杂度为O（n）
#### 索引堆 Index Heap
- index和data 分别保存，实际排序使用index array